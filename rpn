#!/usr/bin/env python

import math
import operator
import re
import sys
from dataclasses import dataclass
from typing import Any


def help():
    print("""rpn by Preston Hunt (https://github.com/presto8/rpn)
Operator    Arguments    Description
   +            2        Add (x+y)
   -            2        Subtract (x-y)
   x *          2        Multiply (x*y)
   /            2        Divide (x/y)
   ^            2        Power (x^y)
   <<           2        Left shift (x << y)
   >>           2        Right shift (x >> y)
   <            2        Less than (1 if x < y else 0)
   >            2        Greater than (1 if x > y else 0)
   mod          2        Modulus (x % y)
   abs          1        Absolute value (|x|)
   sqrt         1        Square root (sqrt(x))
   sum        Stack      Sum of entire stack (x + y + z + w + ...)
   d            1        Drop 1 item from stack
""")


def fail(*args):
    print(*args, file=sys.stderr)
    sys.exit(1)


@dataclass
class Operator:
    func: Any
    arguments: int = 2
    arg_pre_fn: Any = None


ops = {
    '+': Operator(operator.add),
    '-': Operator(operator.sub),
    '*': Operator(operator.mul),
    'x': Operator(operator.mul),
    '^': Operator(operator.pow),
    '/': Operator(operator.truediv),
    '<': Operator(operator.lt),
    '<<': Operator(operator.lshift, arg_pre_fn=int),
    '>>': Operator(operator.rshift, arg_pre_fn=int),
    'mod': Operator(operator.mod),
    'abs': Operator(operator.abs, 1),
    'sqrt': Operator(math.sqrt, 1),
    'sum': Operator(sum, 'all'),
    'd': Operator(lambda x: x[:-1], 'all'),  # drop
}


def print_stack(stack):
    for x in stack:
        print(f"{x:.4f}")


def split_args(*args):
    num_re = re.compile(r'([-+]?[0-9]*\.?[0-9]+(?:[eE][0-9]+)?)')
    for arg in args:
        arg = arg.strip().lower()
        while matches := num_re.match(arg):
            num = matches[0]
            arg = arg[len(num):]
            yield num
        if arg:
            if arg in ops.keys():
                yield arg
            else:
                for op in arg:
                    yield op


def rpn(args):
    stack = []
    for arg in split_args(*args):
        try:
            stack.append(float(arg))
            continue
        except ValueError:
            pass
        op = ops[arg]
        if op.arguments == 'all':
            func_args = [stack]
            stack = []
        else:
            func_args = stack[-op.arguments:]
            stack = stack[:len(stack) - op.arguments]
        if op.arg_pre_fn:
            func_args = [op.arg_pre_fn(x) for x in func_args]
        try:
            answer = op.func(*func_args)
        except TypeError:
            print(f"{arg}: insufficient stack")
            continue
        if not isinstance(answer, list):
            answer = [answer]
        stack += answer
    return stack


if __name__ == '__main__':
    if len(sys.argv) == 2 and sys.argv[1] in ["-h", "--help"]:
        help()
    else:
        stack = rpn(sys.argv[1:])
        print_stack(stack)
