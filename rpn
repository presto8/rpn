#!/usr/bin/env python

import math
import operator
import re
import sys
from dataclasses import dataclass, field
from typing import Any, Callable, Union, Optional


def help():
    print("""rpn by Preston Hunt (https://github.com/presto8/rpn)

Operator    Arguments    Description
   +            2        Add (x+y)
   -            2        Subtract (x-y)
   x *          2        Multiply (x*y)
   /            2        Divide (x/y)
   ^            2        Power (x^y)
   <<           2        Left shift (x << y)
   >>           2        Right shift (x >> y)
   <            2        Less than (1 if x < y else 0)
   >            2        Greater than (1 if x > y else 0)
   <=
   >=
   =, ==, eq
   !=, !==, ne
   mod          2        Modulus (x % y)
   abs          1        Absolute value (|x|)
   sqrt         1        Square root (sqrt(x))
   sum        Stack      Sum of entire stack (x + y + z + w + ...)
   product    Stack      Product of entire stack (x * y * z * w * ...)
   prod       Stack      Alias for product
   drop         1        Drop 1 item from stack
   swap         2        Swap x and y on the stack
   dupe         1        Make dupliate of top item on stack
   _text        0        Push "text" onto stack
""")


class Rpn:
    def __init__(self):
        self.stack = []

    def push(self, *args):
        "Push item(s) onto stack."
        for arg in args:
            self.stack.append(arg)

    def pop(self, n=1):
        "Pop n items from stack."
        pass

    def eval_stack(self):
        "Evaluate entire stack."
        pass

    def eval(self):
        "Evaluate one time."
        pass


def fail(*args):
    print(*args, file=sys.stderr)
    sys.exit(1)


@dataclass
class Operator:
    symbol: str
    func: Callable
    arguments: Union[int, str] = 2
    arg_pre_fn: Any = None
    chainable: bool = False


@dataclass
class ParsedArgument:
    operator: Optional[Operator] = None
    number: Optional[float] = None
    text: Optional[str] = None


OPS = [
    Operator('+', operator.add, chainable=True),
    Operator('-', operator.sub, chainable=True),
    Operator('* x', operator.mul, chainable=True),
    Operator('^', operator.pow),
    Operator('/', operator.truediv, chainable=True),
    Operator('= == eq', operator.eq),
    Operator('!= !== ne', operator.ne),
    Operator('< lt', operator.lt),
    Operator('> gt', operator.gt),
    Operator('<= le lte', operator.le),
    Operator('>= ge gte', operator.ge),
    Operator('<<', operator.lshift, arg_pre_fn=int),
    Operator('>>', operator.rshift, arg_pre_fn=int),
    Operator('mod', operator.mod),
    Operator('abs', operator.abs, 1),
    Operator('sqrt', math.sqrt, 1),
    Operator('sum', sum, 'all'),
    Operator('product prod', math.prod, 'all'),
    Operator('drop', lambda x: x[:-1], 'all'),
    Operator('swap', lambda x, y: [y, x]),
    Operator('dupe', lambda x: [x, x], 1),
]


def print_stack(stack):
    for x in stack:
        if isinstance(x, str):
            print(x)
        else:
            print(f"{x:.4f}")


class InvalidArgument(Exception):
    pass


def split_args(*args):  # ParsedArgument
    num_re = re.compile(r'([-+]?[0-9]*\.?[0-9]+(?:[eE][0-9]+)?)')
    for arg in args:
        arg = arg.strip().lower()
        if matches := num_re.findall(arg):
            assert len(matches) == 1
            num = matches[0]
            # arg = arg[len(num):]
            yield ParsedArgument(number=float(num))
        elif arg[0] == '_':
            yield ParsedArgument(text=arg)
        elif op := get_op(arg):
            yield ParsedArgument(operator=op)
        else:
            raise InvalidArgument(arg)


def get_op(arg) -> Optional[Operator]:
    for op in OPS:
        if arg in op.symbol.split():
            return op
    return None


def rpn(args):
    stack = []
    for arg in split_args(*args):
        if text_or_number := arg.text or arg.number:
            stack.append(text_or_number)
            continue
        op = arg.operator
        if op.arguments == 'all':
            func_args = [stack]
            stack = []
        else:
            func_args = stack[-op.arguments:]
            stack = stack[:len(stack) - op.arguments]
        if op.arg_pre_fn:
            func_args = [op.arg_pre_fn(x) for x in func_args]
        try:
            answer = op.func(*func_args)
        except TypeError:
            print(f"{arg}: insufficient stack")
            continue
        if not isinstance(answer, list):
            answer = [answer]
        stack += answer
    return stack


if __name__ == '__main__':
    if len(sys.argv) == 2 and sys.argv[1] in ["-h", "--help"]:
        help()
    else:
        stack = rpn(sys.argv[1:])
        print_stack(stack)
